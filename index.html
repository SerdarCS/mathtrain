<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Algebra Sprint — Minimal (LaTeX)</title>
  <script>
  // Helper removed: use normal strings with double backslashes for LaTeX
    // Queue elements for typesetting until MathJax is ready
    window.__mjxQueue = [];
    window.__mjxReady = false;
    window.MathJax = {
      tex: {
        inlineMath: [["\\(","\\)"],["$","$"]],
        displayMath: [["\\[","\\]"],["$$","$$"]],
        processEscapes: true
      },
      svg: { fontCache: 'global' },
      startup: {
        typeset: true,
        ready: () => {
          MathJax.startup.defaultReady();
          window.__mjxReady = true;
          if (window.__mjxQueue && window.__mjxQueue.length){
            const els = Array.from(new Set(window.__mjxQueue));
            try{ if (MathJax.typesetClear){ MathJax.typesetClear(els); } }catch(_){ }
            MathJax.typesetPromise(els).catch(()=>{});
            window.__mjxQueue.length = 0;
          }
        }
      }
    };
  </script>
  <!-- Use the full TeX bundle so macros like \dfrac render correctly -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js"></script>
  <style>
    :root{
      /* Only 4 colors to tweak */
      --bg:#0f1222;        /* app background */
      --card:#171a2e;      /* surfaces */
      --ink:#e9ecff;       /* text */
      --accent:#c9d5f0;    
      --radius:16px;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f8fd;
        --card:#ffffff;
        --ink:#111827;
        --accent:#c9d5f0;
        --shadow:0 10px 24px rgba(16,24,40,.12);
      }
    }
    *{box-sizing:border-box}
    body{ margin:0; background:var(--bg); color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial}
    header{ display:flex; align-items:center; justify-content:space-between;
      padding:16px clamp(16px, 3vw, 28px); position:sticky; top:0; z-index:10; background:transparent }
    /* Fixed top blur that does not move with scroll; sits behind header */
    .viewport-blur{ position:fixed; inset:0 auto auto 0; width:100%; height:72px; pointer-events:none; z-index:5;
      -webkit-backdrop-filter:saturate(140%) blur(8px); backdrop-filter:saturate(140%) blur(8px);
      -webkit-mask-image:linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0));
      mask-image:linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0)); }
    body.modal-open header{ display:none }
    .brand{display:flex; gap:12px; align-items:center}
    .brand .logo{ width:36px; height:36px; border-radius:10px;
      background: radial-gradient(120% 120% at 10% 0%, var(--accent), transparent 60%), var(--card);
      box-shadow:var(--shadow);
    }
    .brand h1{font-size:18px; margin:0; letter-spacing:.3px}
    .controls{display:flex; gap:10px; align-items:center}
    button{ appearance:none; border:none; border-radius:12px; padding:12px 16px;
      background:var(--accent); color:#071018; font-weight:700; cursor:pointer; box-shadow:var(--shadow); }
    button.secondary{ background:var(--card); color:var(--ink); font-weight:600; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) }
    main{ max-width:960px; margin:0 auto; padding:24px clamp(16px, 3vw, 28px); }
    .cards{ display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:14px; }
    .card{ background:var(--card); border-radius:var(--radius); padding:16px; box-shadow:var(--shadow), inset 0 0 0 1px rgba(255,255,255,.08); }
    .pill{ font-size:12px; padding:0; color:var(--ink); opacity:.75; font-weight:700; background:transparent; border-radius:0; box-shadow:none }
    .skill-title{font-weight:800; margin:6px 0 8px 0}
    .skill-desc{font-size:13px; color:var(--ink); opacity:.8; min-height:34px}
    .progress{ height:10px; border-radius:999px; background:var(--card); overflow:hidden; margin-top:10px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) }
    .bar{ height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent)); transition:width .35s ease }
    /* Full-screen session that behaves like its own page */
    .session{ position:fixed; inset:0; display:none; background:var(--bg); z-index:9999 }
    .session.open{ display:block }
    .problem-card{ position:relative; background:var(--bg); border-radius:0; padding:clamp(12px,3.5vw,22px); border:none; box-shadow:none; width:100vw; max-height:100vh; overflow-y:auto; overscroll-behavior:contain; display:flex; flex-direction:column }
    .problem-card > .row:first-child{ margin-bottom:10px }
    body.modal-open{ overflow:hidden }
    .prompt{font-size:clamp(17px,4.2vw,20px); font-weight:800; margin:6px 0 10px 0; line-height:1.3}
    .subtle{ color:var(--ink); opacity:.75; font-size:clamp(12px,3.4vw,13px); margin-bottom:8px }
    .mcq{ display:grid; gap:12px; margin-top:10px; margin-bottom:12px; grid-template-columns:1fr }
    .mcq button{text-align:left; background:var(--card); padding:12px 14px; min-height:46px; font-size:clamp(15px,4.0vw,17px); touch-action:manipulation; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08); color:var(--ink); white-space:normal }
    /* Ensure MathJax display math lays out matrices over multiple lines inside buttons */
    .mcq button mjx-container{ display:block !important; overflow:visible }
    .mcq button mjx-container[display="true"]{ margin: 4px 0; text-align:left !important }
    /* Left-align display math in prompts and within the session card */
    .problem-card mjx-container[display="true"]{ text-align:left !important; margin-left:0 !important }
    /* Session buttons */
    .problem-card .row button.secondary{ background:var(--card); color:var(--ink); box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) }
    .problem-card .row button.secondary:hover,
    .problem-card .row button.secondary:focus-visible,
    .mcq button:hover,
    .mcq button:focus-visible{ box-shadow: inset 0 0 0 2px var(--ink); outline:none }
    .problem-card .row button.secondary:active,
    .mcq button:active{ transform: translateY(0.5px) }
    /* Stronger visible outlines in light mode to match dark mode contrast */
    @media (prefers-color-scheme: light){
      .mcq button,
      .problem-card .row button.secondary,
      .feedback,
      .card,
      .progress{
        box-shadow: inset 0 0 0 1px rgba(16,24,40,.12);
      }
      .pill{ box-shadow: none !important; background: transparent !important; }
    }
    .answer-row{ display:none }
    input[type="text"]{ flex:1; padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.12);
      background:transparent; color:var(--ink); font-size:16px; outline:none }
    .feedback{ margin:0 0 8px 0; padding:0; background:transparent; display:block; font-weight:700; box-shadow:none }
    .hint{ font-size:14px; color:var(--ink); opacity:.75; margin-top:8px; display:none }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:12px }
    .spacer{ height:20px }
    .problem-card{ padding-bottom:calc(env(safe-area-inset-bottom) + 24px) }
    body.modal-open header{ display:none }
    /* Sticky top bar so Home is always reachable */
    /* Session header row should behave like normal content (no sticky bar) */
    .topbar{ position:static; padding-top:0; padding-bottom:6px; box-shadow:none; background:transparent }
    .topbar::before{ display:none }
    /* Prevent any horizontal scrolling in page and session */
    html, body{ overflow-x:hidden }
    .session{ overflow-x:hidden }
    .problem-card{ overflow-x:hidden }
    .topbar .pill{ font-size:11px; padding:0 }
    #homeBtn{ margin-left:auto; padding:6px 10px; font-size:12px; border-radius:10px }
    /* Feedback modal */
    .feedback-modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.45); z-index:10000 }
    .feedback-modal.open{ display:flex }
    .feedback-card{ background:var(--card); color:var(--ink); width:min(560px,92vw); border-radius:12px; padding:16px; box-shadow: var(--shadow), inset 0 0 0 1px rgba(255,255,255,.08) }
    .feedback-card .actions{ margin-top:12px; display:flex; justify-content:flex-end; gap:10px }
    @media (max-width:640px){
      .controls{ display:none }
      .mcq button, .row button{ width:100% }
      .row{ gap:8px }
    }
    .footer{ margin-top:26px; font-size:13px; color:var(--ink); opacity:.65; text-align:center }
    @media (max-width:560px){ .cards{ grid-template-columns: 1fr } }
  </style>
</head>
<body>
  <div class="viewport-blur" aria-hidden="true"></div>
  <header>
    <div class="brand" role="banner" aria-label="Algebra Sprint">
      <div class="logo" aria-hidden="true"></div>
      <h1 style="position:relative; z-index:11">Algebra Sprint</h1>
    </div>
    
  </header>

  <main>
    <section class="cards" id="skills">
      <div class="card">
        <div class="pill">Skill</div>
        <div class="skill-title">Arithmetic & Simplify</div>
        <div class="skill-desc">Fractions, exponents, order–of–operations.</div>
        <button data-skill="arithmetic">Practice</button>
      </div>

      <div class="card">
        <div class="pill">Skill</div>
        <div class="skill-title">Linear & Quadratic</div>
        <div class="skill-desc">Solve \(ax+b=c\), expand, factor nice quadratics.</div>
        <button data-skill="algebra">Practice</button>
      </div>

      <div class="card">
        <div class="pill">Skill</div>
        <div class="skill-title">Calculus Intuition</div>
        <div class="skill-desc">Derivatives, limits, and basic integrals.</div>
        <button data-skill="calculus">Practice</button>
      </div>

      <div class="card">
        <div class="pill">Skill</div>
        <div class="skill-title">Probability Basics</div>
        <div class="skill-desc">Coins, dice, combinations, and simple EV.</div>
        <button data-skill="probability">Practice</button>
      </div>

      <div class="card">
        <div class="pill">Skill</div>
        <div class="skill-title">Linear Algebra</div>
        <div class="skill-desc">2×2 matrix ops, small vectors, 2×2 det.</div>
        <button data-skill="linalg">Practice</button>
      </div>

      <div class="card">
        <div class="pill">Mode</div>
        <div class="skill-title">Mixed Session</div>
        <div class="skill-desc">A short set across all skills. 10 questions, instant feedback.</div>
        <button data-skill="mixed">Start 10‑Q Sprint</button>
      </div>
    </section>

    <section class="session" id="session" aria-live="polite">
      <div class="problem-card" id="problemCard">
        <div class="row topbar">
          <div class="pill" id="skillTag">Skill</div>
          <div class="pill" id="progressTag">0 / 10</div>
          <button class="secondary" id="homeBtn" style="margin-left:auto">Home</button>
        </div>
        <p class="prompt" id="prompt">Prompt goes here</p>
        <p class="subtle" id="instruction">Choose the correct answer.</p>

        <div id="inputArea" class="answer-row">
          <input type="text" id="answerInput" inputmode="decimal" aria-label="Your answer" placeholder="Type answer…" />
          <button id="checkBtn">Check</button>
        </div>

        <div id="mcqArea" class="mcq" role="group" aria-label="Choices" style="display:none"></div>

        <div class="row">
          <button class="secondary" id="hintBtn">Hint</button>
          <button class="secondary" id="skipBtn" title="Skip">Skip</button>
        </div>

        
        <div class="hint" id="hint"></div>

        <div class="spacer"></div>
        <div class="progress"><div class="bar" id="sessionBar"></div></div>
      </div>
      <div id="feedbackModal" class="feedback-modal" role="dialog" aria-modal="true" aria-live="polite">
        <div class="feedback-card">
          <div class="feedback" id="feedback"></div>
          <div class="actions">
            <button class="secondary" id="closeFeedbackBtn">Close</button>
            <button id="nextFeedbackBtn">Next</button>
          </div>
        </div>
      </div>
      
    </section>
  </main>

  <script>
  const $ = (id)=>document.getElementById(id);
  const rng=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const choice=(arr)=>arr[Math.floor(Math.random()*arr.length)];
  const shuffle=(arr)=>arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
  const fmt = (x)=> (Math.abs(x) < 1e-12 ? "0" : (Number.isInteger(x) ? String(x) : String(+x.toFixed(6))).replace(/\.0+$/,''));
  const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; };
  const fracStr = (num, den)=>{ const s = (den<0?-1:1); num*=s; den*=s; const g=gcd(num,den); num/=g; den/=g; return den===1? String(num):`\\frac{${num}}{${den}}`; };
  // Fraction helpers for exact probability arithmetic
  const reduceFrac = (n,d)=>{ const s = d<0?-1:1; n*=s; d*=s; const g=gcd(n,d); return {n:n/g, d:d/g}; };
  const addFrac = (n1,d1,n2,d2)=> reduceFrac(n1*d2 + n2*d1, d1*d2);
  const subFrac = (n1,d1,n2,d2)=> reduceFrac(n1*d2 - n2*d1, d1*d2);
  const mulFrac = (n1,d1,n2,d2)=> reduceFrac(n1*n2, d1*d2);
  const divFrac = (n1,d1,n2,d2)=> reduceFrac(n1*d2, d1*n2);
  const toFracStr = (f)=> fracStr(f.n, f.d);
  const sign = (v)=> v>=0?'+':'-';
  const abs = (v)=> Math.abs(v);
  const lin = (k,m,x='x')=> `${k}${x} ${sign(m)} ${abs(m)}`;
  const coef = (k)=> k===1? '' : (k===-1? '-' : String(k));
  // Matrix/Vector helpers (small sizes for mental math)
  const mat2 = (a,b,c,d)=> [[a,b],[c,d]];
  const vec = (...xs)=> xs.map(Number);
  const mat2MulVec2 = (M,v)=> [ M[0][0]*v[0] + M[0][1]*v[1], M[1][0]*v[0] + M[1][1]*v[1] ];
  const mat2Mul = (A,B)=> [
    [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
    [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
  ];
  const det2 = (M)=> M[0][0]*M[1][1] - M[0][1]*M[1][0];
  // Use escaped backslashes so JS strings preserve LaTeX commands
  const matToLatex = (rows)=> `\\begin{bmatrix} ${rows.map(r=> r.map(x=> fmt(x)).join(' & ')).join(' \\\\ ')} \\end{bmatrix}`;
  const vecToLatex = (v)=> `\\begin{bmatrix} ${v.map(x=> fmt(x)).join(' \\\\ ')} \\end{bmatrix}`;
  // Format polynomial Ax^2 + Bx + C with 0-term removal
  function polyStr(A,B,C){
    const terms=[];
    if (A!==0){ terms.push(A===1? 'x^2' : (A===-1? '-x^2' : `${A}x^2`)); }
    if (B!==0){
      const tb = Math.abs(B)===1? 'x' : `${Math.abs(B)}x`;
      if (terms.length===0) terms.push(B<0? `-${tb}` : `${tb}`);
      else terms.push(B<0? `- ${tb}` : `+ ${tb}`);
    }
    if (C!==0){
      const tc = `${Math.abs(C)}`;
      if (terms.length===0) terms.push(C<0? `-${tc}` : `${tc}`);
      else terms.push(C<0? `- ${tc}` : `+ ${tc}`);
    }
    return terms.length? terms.join(' ') : '0';
  }
  // Ensure 5 unique choices including the correct answer
  function finalizeChoices(candidates, correct, need=5){
    const set = new Set();
    if (correct!=null) set.add(String(correct));
    (candidates||[]).forEach(x=>{ if (x!=null){ const s=String(x); if(!set.has(s)) set.add(s); } });
    const fillers = ['0','1','2','3','4','-1','\\frac{1}{2}','\\frac{2}{3}','e'];
    for (const f of fillers){ if (set.size>=need) break; if (!set.has(f)) set.add(f); }
    const arr = shuffle(Array.from(set));
    const choices = arr.slice(0, need);
    return { choices, correctIndex: choices.indexOf(String(correct)) };
  }
  const fact = (n)=>{ let r=1; for(let i=2;i<=n;i++) r*=i; return r; };
  const nCr = (n,r)=>{ if(r<0||r>n) return 0; r=Math.min(r,n-r); let num=1,den=1; for(let i=1;i<=r;i++){ num*= (n-r+i); den*=i; } return Math.round(num/den); };
  const nPr = (n,r)=>{ if(r<0||r>n) return 0; let v=1; for(let i=0;i<r;i++) v*= (n-i); return v; };
  const oneOver = (k)=>{
    if (k===1) return '';
    if (k===-1) return '-';
    const s = k<0?'-':'';
    return `${s}\\frac{1}{${Math.abs(k)}}`;
  };
  // Build multiple-choice numeric options around the correct answer
  function buildNumericMCQ(ans){
    const correct = fmt(ans);
    const opts = new Set([correct]);
    const base = Number(correct);
    const seed = [base + 1, base - 1, -base, base * 2, base / 2, base + 0.5, base - 0.5];
    seed.forEach(v=>{ if (opts.size < 5) opts.add(fmt(v)); });
    while (opts.size < 5){
      const v = base + (rng(-9,9))/rng(2,6);
      opts.add(fmt(v));
      if (opts.size > 12) break; // safety
    }
    const choices = shuffle(Array.from(opts)).slice(0,5);
    const correctIndex = choices.indexOf(correct);
    return { choices, correctIndex };
  }
  function parseNumber(input){
    const s = String(input).trim(); if(!s) return NaN;
    if (/^-?\d+\/-?\d+$/.test(s)){ const [a,b]=s.split('/').map(Number); if (b===0) return NaN; return a/b; }
    if (/^[\+\-]?\d*\.?\d+(e[\+\-]?\d+)?$/i.test(s)) return Number(s);
    if (/^[0-9\.\+\-\*\/\^\(\)\sπpie]+$/i.test(s)){
      let expr = s.replace(/π/gi, Math.PI).replace(/\be\b/g, Math.E).replace(/\^/g, '**');
      try{ const val = Function('"use strict"; return ('+expr+')')(); return typeof val==="number" && isFinite(val) ? val : NaN; }catch{ return NaN; }
    }
    return NaN;
  }
  function nearlyEqual(a,b,eps=1e-6){ const scale = Math.max(1, Math.abs(a), Math.abs(b)); return Math.abs(a-b) <= eps * scale; }
  function typeset(el){
    if (window.MathJax && MathJax.typesetPromise && window.__mjxReady){
      try{ if (MathJax.typesetClear){ MathJax.typesetClear([el]); } }catch(_){}
      MathJax.typesetPromise([el]).catch(()=>{});
    } else {
      (window.__mjxQueue || (window.__mjxQueue=[])).push(el);
    }
  }

  function genArithmetic(){
    const mode = choice(["fraction","power","mixed"]);
    if (mode==="fraction"){
      const a=rng(1,9), b=rng(2,9), c=rng(1,9), d=rng(2,9);
      const prompt = `Compute $\\frac{${a}}{${b}} + \\frac{${c}}{${d}}$.`;
      const ans = a/b + c/d;
      const hint = `Common denominator is ${b*d}.`;
      const explain = `\(\frac{${a}}{${b}}+\frac{${c}}{${d}} = \frac{${a*d}+${c*b}}{${b*d}} = ${fmt((a*d+c*b)/(b*d))}\).`;
      const {choices, correctIndex} = buildNumericMCQ(ans);
      return {skill:"arithmetic", type:"mcq", prompt, choices, correctIndex, hint, explain};
    } else if (mode==="power"){
      const x=rng(2,5), p=rng(2,4), y=rng(2,5), q=rng(2,3);
      const prompt = `Evaluate $${x}^{${p}} - ${y}^{${q}}$.`;
      const ans = x**p - y**q; const hint = `Compute powers separately, then subtract.`; const explain = `\\(${x}^{${p}}=${x**p},\; ${y}^{${q}}=${y**q} \\Rightarrow ${ans}\\).`;
      const {choices, correctIndex} = buildNumericMCQ(ans);
      return {skill:"arithmetic", type:"mcq", prompt, choices, correctIndex, hint, explain};
    } else {
      const a=rng(2,9), b=rng(1,9), c=rng(1,9);
      const prompt = `Compute $${a}(${b}+${c}) - ${c}^2$.`;
      const dist = a*b + a*c;
      const c2 = c*c;
      const ans = a*(b+c) - c2;
      const hint = c2===0 ? `Distribute.` : `Distribute then subtract ${c}^2.`;
      const explain = c2===0
        ? `\\(${a}(${b}+${c}) = ${dist}\\).`
        : `\\(${a}(${b}+${c}) - ${c}^2 = ${a*b}+${a*c} - ${c2} = ${ans}\\).`;
      const {choices, correctIndex} = buildNumericMCQ(ans);
      return {skill:"arithmetic", type:"mcq", prompt, choices, correctIndex, hint, explain};
    }
  }
  function genLinear(){
    let a=rng(2,9); const b=rng(-9,9), c=rng(-9,9); if (a===0) a=2; const x=(c-b)/a;
    const prompt=`Solve for x: $${a}x ${b>=0?'+':'-'} ${Math.abs(b)} = ${c}$.`;
    const hint=`Isolate x: subtract ${b>=0?b:('('+b+')')} then divide by ${a}.`;
    const explain = (b===0)
      ? `\\(${a}x = ${c};\\; x = ${c}/${a} = ${fmt(x)}\\).`
      : `\\(${a}x = ${c} ${b>=0?'-':'+'} ${Math.abs(b)} = ${fmt(c-b)};\\; x = (${fmt(c-b)})/${a} = ${fmt(x)}\\).`;
    const {choices, correctIndex} = buildNumericMCQ(x);
    return {skill:"algebra", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genExpand(){
    const a=rng(1,6), b=rng(-6,6), c=rng(1,6), d=rng(-6,6);
    const A=a*c, B=a*d + b*c, C=b*d;
    const correct = polyStr(A,B,C);
    const d1 = polyStr(A,B,-C);
    const d2 = polyStr(A,-B,C);
    const d3 = polyStr((a+b)*(c+d), B, C);
    const extra = polyStr(A,B,0); // drops constant term
    const cands = shuffle([ d1,d2,d3,extra ]);
    const {choices, correctIndex} = finalizeChoices(cands, correct, 5);
    const prompt = `Expand: $(${a}x ${b>=0?'+':'-'} ${Math.abs(b)})(${c}x ${d>=0?'+':'-'} ${Math.abs(d)})$.`;
    const hint = `Use FOIL (distribute).`;
    const explain = `\\( (${a}x+${b})(${c}x+${d}) = ${polyStr(A,B,C)} \\)`;
    return {skill:"algebra", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genFactor(){
    const r1=rng(-7,7) || 1; const r2=rng(-7,7) || -1; const s = -(r1 + r2); const p = r1 * r2;
    const correct = `(x ${-r1>=0?'+':''}${-r1})(x ${-r2>=0?'+':''}${-r2})`;
    const w1 = `(x ${r1>=0?'+':''}${r1})(x ${-r2>=0?'+':''}${-r2})`;
    const w2 = `(x ${-r1>=0?'+':''}${-r1})(x ${r2>=0?'+':''}${r2})`;
    const w3 = `(x ${-r1>=0?'+':''}${-r1})(x ${-r2>=0?'+':''}${-r2 + (r1===r2?1:0)})`;
    const w4 = `(x ${r1>=0?'+':''}${r1})(x ${r2>=0?'+':''}${r2})`;
    const cands = shuffle([ w1, w2, w3, w4 ]);
    const {choices:choicesF, correctIndex:ciF} = finalizeChoices(cands, correct, 5);
    const prompt = `Factor: $x^2 ${s>=0?'+':'-'} ${Math.abs(s)}x ${p>=0?'+':'-'} ${Math.abs(p)}$.`;
    const hint = `Find integers \(r_1, r_2\) with \(r_1+r_2=${-s}\) and \(r_1\cdot r_2=${p}\).`;
    const explain = `\((x - r_1)(x - r_2)\), with \(r_1=${r1},\; r_2=${r2}\).`;
    return {skill:"algebra", type:"mcq", prompt, choices:choicesF, correctIndex:ciF, hint, explain};
  }
  function genDerivativePoint(){
    const a = rng(-3,3);
    const pattern = choice(["powerChain","sinLinear","expQuad","product"]);
    let prompt, ans, hint, explain;
    if (pattern==="powerChain"){
      let k=rng(2,5), m=rng(1,4), n=rng(2,4);
      // keep (k*a+m) manageable for mental math
      let ua = k*a + m; let guard=0;
      while (Math.abs(ua) > 5 && guard++ < 10){ k=rng(2,5); m=rng(1,4); ua = k*a + m; }
      prompt = `Compute \\(f'(${a})\\) for \\(f(x)=( ${k}x + ${m} )^{${n}}\\).`;
      ans = n * (k*a+m)**(n-1) * k;
      hint = `\\((u^n)' = n u^{n-1} u'\\) with \\(u=${k}x+${m}\\).`;
      explain = `\\(f'(x)=${n}(${k}x+${m})^{${n-1}}\\cdot ${k}\\). Evaluate at \\(x=${a}\\).`;
      // Always symbolic answer to avoid calculators
      const nk = n*k;
      const correct = `${nk}(${ua})^{${n-1}}`;
      const d1 = `${n}(${ua})^{${n-1}}`; // missing chain factor
      const d2 = `${nk}(${ua})^{${n}}`;  // wrong power
      const d3 = `${nk}(${ua+1})^{${n-1}}`; // shifted input
      const d4 = `${k}(${ua})^{${n-1}}`;
      const {choices:ch1, correctIndex:ci1} = finalizeChoices([d1,d2,d3,d4], correct, 5);
      return {skill:"calculus", type:"mcq", prompt, choices:ch1, correctIndex:ci1, hint, explain};
    } else if (pattern==="sinLinear"){
      const k=rng(2,6), m=rng(-3,3);
      prompt = `Compute \\(f'(${a})\\) for \\(f(x)=\\sin(${k}x ${m>=0?'+':'-'} ${Math.abs(m)})\\).`;
      ans = Math.cos(k*a + m) * k;
      hint = `\\((\\sin u)' = \\cos u \\cdot u'\\) with \\(u=${k}x+${m}\\).`;
      explain = `\\(f'(x)=${k}\\cos(${k}x+${m})\\). Evaluate at \\(x=${a}\\).`;
      const angle = `${k*a + m}`;
      const ck = coef(k);
      const correct = `${ck}\\cos(${angle})`;
      const alt1 = `${ck}\\sin(${angle})`;
      const alt2 = `${coef(-k)}\\cos(${angle})`;
      const alt3 = `${coef(k===1?2:k+1)}\\cos(${angle})`;
      const alt4 = `${ck}\\cos(${angle}+1)`;
      const {choices:ch2, correctIndex:ci2} = finalizeChoices([alt1,alt2,alt3,alt4], correct, 5);
      return {skill:"calculus", type:"mcq", prompt, choices:ch2, correctIndex:ci2, hint, explain};
    } else if (pattern==="expQuad"){
      const k=rng(1,3), m=rng(1,3);
      prompt = `Compute \\(f'(${a})\\) for \\(f(x)=e^{${k}x^2 + ${m}}\\).`;
      ans = Math.exp(k*a*a + m) * (2*k*a);
      hint = `\\((e^{u})' = e^{u}\\cdot u'\\) with \\(u=${k}x^2+${m}\\).`;
      explain = `\\(f'(x)=e^{${k}x^2+${m}}\\cdot ${2*k}x\\). Evaluate at \\(x=${a}\\).`;
      const expv = `${k*a*a + m}`;
      const factor = 2*k*a;
      const correct = factor===0? '0' : `${coef(factor)}e^{${expv}}`;
      const d1 = `${2*k}e^{${expv}}`; // forgot to plug x=a
      const d2 = `e^{${expv}}`;      // missing factor
      const d3 = `e^{${k}x^2+${m}}\\cdot ${2*k}x`; // not evaluated at a
      const d4 = `${2*a}e^{${expv}}`;
      const {choices:ch3, correctIndex:ci3} = finalizeChoices([d1,d2,d3,d4], correct, 5);
      return {skill:"calculus", type:"mcq", prompt, choices:ch3, correctIndex:ci3, hint, explain};
    } else {
      const A=rng(1,4), B=rng(-4,4), C=rng(1,4);
      prompt = `Compute \\(f'(${a})\\) for \\(f(x)=(${A}x ${B>=0?'+':'-'} ${Math.abs(B)})\\sin(${C}x)\\).`;
      const fp = A*Math.sin(C*a) + (A*a+B)*Math.cos(C*a)*C;
      ans = fp;
      hint = `Product rule: \\(u'v + uv'\\), and \\((\\sin cx)'=c\\cos cx\\).`;
      const ca = `${C*a}`;
      const ampCos = (A*a+B)*C;
      const term1 = `${coef(A)}\\sin(${ca})`;
      const term2 = ampCos===0? '' : `${coef(ampCos)}\\cos(${ca})`;
      const correct = term2? `${term1} ${term2.startsWith('-')?'':'+'} ${term2}` : term1;
      const evalStr = term2? `${term1} ${term2.startsWith('-')?'':'+'} ${term2}` : term1;
      const d1t2 = ampCos===0? '' : `${coef(ampCos)}\\sin(${ca})`;
      const d1 = d1t2? `${coef(A)}\\cos(${ca}) ${d1t2.startsWith('-')?'':'+'} ${d1t2}` : `${coef(A)}\\cos(${ca})`;
      const d2t2amp = (A*a+B); // missing C
      const d2t2 = d2t2amp===0? '' : `${coef(d2t2amp)}\\cos(${ca})`;
      const d2 = d2t2? `${term1} ${d2t2.startsWith('-')?'':'+'} ${d2t2}` : term1;
      const d3t2 = ampCos===0? '' : `${coef(-ampCos)}\\cos(${ca})`;
      const d3 = d3t2? `${term1} ${d3t2.startsWith('-')?'':'+'} ${d3t2}` : term1;
      const d4term1 = `${coef(-A)}\\sin(${ca})`;
      const d4 = term2? `${d4term1} ${term2.startsWith('-')?'':'+'} ${term2}` : d4term1;
      const {choices:ch4, correctIndex:ci4} = finalizeChoices([d1,d2,d3,d4], correct, 5);
      const explain = `\\(f'(x)=${A}\\sin(${C}x)+(${A}x+${B})\\cdot ${C}\\cos(${C}x)\\). Evaluate at \\(x=${a}\\): \\(${evalStr}\\).`;
      return {skill:"calculus", type:"mcq", prompt, choices:ch4, correctIndex:ci4, hint, explain};
    }
    // Fallback shouldn't happen, but ensure we return something
    const {choices, correctIndex} = buildNumericMCQ(ans);
    return {skill:"calculus", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  // Basic integrals
  function genIntegralPoly(){
    const a = rng(1,6) * (Math.random()<0.3?-1:1);
    const n = rng(0,3);
    const prompt = `Find an antiderivative: \\int ${a}x^{${n}}\\,dx`;
    const coeff = fracStr(a, n+1);
    const correct = `${coeff}x^{${n+1}} + C`;
    const d1 = `${a}x^{${n+1}} + C`;
    const d2 = `${coeff}x^{${n}} + C`;
    const d3 = `${fracStr(a, n+2)}x^{${n+2}} + C`;
    const d4 = `-${coeff}x^{${n+1}} + C`;
    const {choices:chP, correctIndex:ciP} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    return {skill:"calculus", type:"mcq", prompt:`Compute: \\( \\int ${a}x^{${n}}\\,dx \\)`, choices:chP, correctIndex:ciP, hint:`Power rule: \\int x^n dx = x^{n+1}/(n+1) + C`, explain:`Antiderivative is \\(${correct}\\)`};
  }
  // Probability generators
  function genCoinBinom(){
    const n = rng(3,6); const k = rng(0,n);
    const comb = nCr(n,k);
    const prompt = `A fair coin is flipped ${n} times. What is $P(\\text{exactly }${k} \\text{ heads})$?`;
    const correct = `${fracStr(comb, 2**n)}`;
    const distract = new Set();
    const tryPush=(s)=>{ if (s!==correct) distract.add(s); };
    if (k-1>=0) tryPush(fracStr(nCr(n,k-1), 2**n));
    if (k+1<=n) tryPush(fracStr(nCr(n,k+1), 2**n));
    tryPush(fracStr(1, 2**n));
    tryPush(fracStr(nCr(n,k), 2**(n-1)));
    if (k-2>=0) tryPush(fracStr(nCr(n,k-2), 2**n));
    const cand = shuffle(Array.from(distract));
    const {choices:chB, correctIndex:ciB} = finalizeChoices(cand, correct, 5);
    return {skill:"probability", type:"mcq", prompt, choices:chB, correctIndex:ciB, hint:`Use $\\binom{n}{k}/2^n$.`, explain:`$P=\\binom{${n}}{${k}}/2^{${n}} = ${correct}$.`};
  }
  function genTwoDiceSum(){
    const s = rng(2,12);
    const counts = {2:1,3:2,4:3,5:4,6:5,7:6,8:5,9:4,10:3,11:2,12:1};
    const c = counts[s];
    const prompt = `Two fair dice are rolled. What is $P(\\text{sum}=${s})$?`;
    const correct = `${fracStr(c,36)}`;
    const near = [s-1,s+1].filter(x=>counts[x]);
    const dset = new Set();
    near.forEach(x=> dset.add(fracStr(counts[x],36)));
    dset.add(fracStr(c,12)); // wrong denominator
    dset.add(fracStr(36-c,36)); // complement count
    dset.add(fracStr(1,6)); // common mistake
    const {choices:chD, correctIndex:ciD} = finalizeChoices(Array.from(dset), correct, 5);
    return {skill:"probability", type:"mcq", prompt, choices:chD, correctIndex:ciD, hint:`Favorable outcomes over $36$.`, explain:`There are ${c} pairs giving ${s}, so $${correct}$.`};
  }
  function genIndependence(){
    const dieEvents = [
      {txt:'even', m:3},
      {txt:'odd', m:3},
      {txt:'prime', m:3}, // 2,3,5
      {txt:'a multiple of 3', m:2},
      {txt:'greater than 4', m:2},
      {txt:'less than 3', m:2}
    ];
    const ev = choice(dieEvents);
    const prompt = `A fair coin is flipped and a fair die is rolled. What is $P(\\text{Heads AND die is ${ev.txt}})$?`;
    const correct = `${fracStr(ev.m,12)}`; // (1/2)*(m/6) = m/12
    const ds = new Set([
      fracStr(ev.m,6), // forgot multiply
      fracStr(6-ev.m,12), // complement die event
      fracStr(ev.m,36), // wrong denominator
      fracStr(1,2) // coin only
    ]);
    const {choices:chI, correctIndex:ciI} = finalizeChoices(Array.from(ds), correct, 5);
    return {skill:"probability", type:"mcq", prompt, choices:chI, correctIndex:ciI, hint:`Independence: multiply $1/2$ by $${fracStr(ev.m,6)}$.`, explain:`$P=\\frac12\\cdot \\frac{${ev.m}}{6} = ${correct}$.`};
  }
  function genExpectedDie(){
    const mode = choice(['X','2X+1','X-1']);
    const prompt = mode==='X'
      ? `Let $X$ be a fair die roll. Compute $E[X]$.`
      : (mode==='2X+1' ? `Let $X$ be a fair die roll. Compute $E[2X+1]$.` : `Let $X$ be a fair die roll. Compute $E[X-1]$.`);
    const EX = fracStr(7,2);
    let correct, distractors;
    if (mode==='X'){
      correct = EX; distractors = ['3','4', fracStr(8,3), fracStr(5,2)];
    } else if (mode==='2X+1'){
      correct = '8'; distractors = ['7', '9', fracStr(15,2), '6'];
    } else {
      correct = fracStr(5,2); distractors = ['2', EX, '3', fracStr(3,2)];
    }
    const {choices:chE, correctIndex:ciE} = finalizeChoices(distractors, correct, 5);
    return {skill:"probability", type:"mcq", prompt, choices:chE, correctIndex:ciE, hint:`Use linearity of expectation.`, explain:`$E[X]=${EX}$.`};
  }
  function genBayesLikelihoods(){
    // Given P(A), P(B|A), P(B|~A) compute P(A|B)
    const dA = rng(3,6), a = rng(1,dA-1);
    const e1 = rng(2,6), b1 = rng(1,e1-1);
    const e2 = rng(2,6), b2 = rng(1,e2-1);
    const pA = reduceFrac(a,dA);
    const pNotA = reduceFrac(dA-a, dA);
    const pB_A = reduceFrac(b1,e1);
    const pB_notA = reduceFrac(b2,e2);
    const pAB = mulFrac(pA.n,pA.d,pB_A.n,pB_A.d);
    const pNotA_B = mulFrac(pNotA.n,pNotA.d,pB_notA.n,pB_notA.d);
    const pB = addFrac(pAB.n,pAB.d,pNotA_B.n,pNotA_B.d);
    const pA_given_B = divFrac(pAB.n,pAB.d,pB.n,pB.d);
    const prompt = `Given $P(A)=${toFracStr(pA)}$, $P(B\\mid A)=${toFracStr(pB_A)}$, and $P(B\\mid \\neg A)=${toFracStr(pB_notA)}$, compute $P(A\\mid B)$.`;
    const correct = toFracStr(pA_given_B);
    const d1 = toFracStr(pB_A);
    const d2 = toFracStr(pA);
    const d3 = toFracStr(pNotA); // common confusion with complement
    const d4 = toFracStr(pNotA_B); // numerator wrong part
    const {choices, correctIndex} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    const hint = `Bayes: $P(A\\mid B)=\\dfrac{P(B\\mid A)P(A)}{P(B\\mid A)P(A)+P(B\\mid \\neg A)(1-P(A))}$.`;
    const explain = `$= \\dfrac{${toFracStr(pB_A)}\\cdot ${toFracStr(pA)}}{${toFracStr(pB_A)}\\cdot ${toFracStr(pA)} + ${toFracStr(pB_notA)}\\cdot ${toFracStr(pNotA)}} = ${correct}$.`;
    return {skill:"probability", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genBayesGivenB(){
    // Given P(A), P(B|A), P(B|~A), we can also present P(B) as a given and ask P(A|B)
    // Compute P(B) exactly and present it.
    const dA = rng(3,6), a = rng(1,dA-1);
    const e1 = rng(2,6), b1 = rng(1,e1-1);
    const e2 = rng(2,6), b2 = rng(1,e2-1);
    const pA = reduceFrac(a,dA);
    const pNotA = reduceFrac(dA-a, dA);
    const pB_A = reduceFrac(b1,e1);
    const pB_notA = reduceFrac(b2,e2);
    const pAB = mulFrac(pA.n,pA.d,pB_A.n,pB_A.d);
    const pNotA_B = mulFrac(pNotA.n,pNotA.d,pB_notA.n,pB_notA.d);
    const pB = addFrac(pAB.n,pAB.d,pNotA_B.n,pNotA_B.d);
    const pA_given_B = divFrac(pAB.n,pAB.d,pB.n,pB.d);
    const prompt = `Given $P(A)=${toFracStr(pA)}$, $P(B)=${toFracStr(pB)}$, and $P(B\\mid A)=${toFracStr(pB_A)}$, compute $P(A\\mid B)$.`;
    const correct = toFracStr(pA_given_B);
    const d1 = toFracStr(pB_A);
    const d2 = toFracStr(pA);
    const d3 = toFracStr(pNotA);
    const d4 = toFracStr(pB);
    const {choices, correctIndex} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    const hint = `Bayes: $P(A\\mid B)=\\dfrac{P(B\\mid A)P(A)}{P(B)}$.`;
    const explain = `$= \\dfrac{${toFracStr(pB_A)}\\cdot ${toFracStr(pA)}}{${toFracStr(pB)}} = ${correct}$.`;
    return {skill:"probability", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genChoose(){
    const n = rng(5,8); const k = rng(1,n-1);
    const prompt = `How many ways to choose ${k} items from ${n}?`;
    const correct = String(nCr(n,k));
    const d1 = String(nPr(n,k));
    const d2 = String(nCr(n, Math.max(1, k-1)));
    const d3 = String(nCr(n, Math.min(n-1, k+1)));
    const d4 = String(n**k);
    const {choices:chC, correctIndex:ciC} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    return {skill:"probability", type:"mcq", prompt, choices:chC, correctIndex:ciC, hint:`Use $\\binom{n}{k}$.`, explain:`$\\binom{${n}}{${k}} = ${correct}$.`};
  }
  function genIntegralTrig(){
    const k = rng(1,5) * (Math.random()<0.2?-1:1);
    const m = rng(-3,3);
    if (Math.random()<0.5){
      // integral of cos(kx+m)
      const prompt = `Compute: \\( \\int \\cos(${k}x ${sign(m)} ${abs(m)})\\,dx \\)`;
      const correct = `${oneOver(k)}\\sin(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w1 = `-${oneOver(k)}\\sin(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w2 = `${oneOver(k)}\\cos(${k}x ${sign(m)} ${abs(m)}) + C`;
      const k2 = Math.abs(k)+1;
      const w3 = `${coef(k2)}\\sin(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w4 = `-${oneOver(k)}\\cos(${k}x ${sign(m)} ${abs(m)}) + C`;
      const {choices:chT1, correctIndex:ciT1} = finalizeChoices([w1,w2,w3,w4], correct, 5);
      return {skill:"calculus", type:"mcq", prompt, choices:chT1, correctIndex:ciT1, hint:`\\int \\cos(u)du = \\sin(u) + C, \\; du = ${k}dx`, explain:`Multiply by \\(${oneOver(k)||'1'}\\) for chain.`};
    } else {
      // integral of sin(kx+m)
      const prompt = `Compute: \\( \\int \\sin(${k}x ${sign(m)} ${abs(m)})\\,dx \\)`;
      const factor = fracStr(-1, k);
      const correct = `${factor}\\cos(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w1 = `${fracStr(1,k)}\\cos(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w2 = `${factor}\\sin(${k}x ${sign(m)} ${abs(m)}) + C`;
      const k2 = Math.abs(k)+1;
      const w3 = `${coef(k2)}\\cos(${k}x ${sign(m)} ${abs(m)}) + C`;
      const w4 = `${fracStr(1,k)}\\sin(${k}x ${sign(m)} ${abs(m)}) + C`;
      const {choices:chT2, correctIndex:ciT2} = finalizeChoices([w1,w2,w3,w4], correct, 5);
      return {skill:"calculus", type:"mcq", prompt, choices:chT2, correctIndex:ciT2, hint:`\\int \\sin(u)du = -\\cos(u) + C`, explain:`Chain factor \\(${oneOver(k)||'1'}\\).`};
    }
  }
  function genIntegralExp(){
    const a = choice([1,2,3,4]) * (Math.random()<0.25?-1:1);
    const b = rng(-3,3);
    const prompt = `Compute: \\( \\int e^{${a}x ${sign(b)} ${abs(b)}}\\,dx \\)`;
    const correct = `${oneOver(a)}e^{${a}x ${sign(b)} ${abs(b)}} + C`;
    const w1 = `${oneOver(-a)}e^{${a}x ${sign(b)} ${abs(b)}} + C`; // wrong overall factor sign
    const w2 = `${oneOver(a)}e^{${a}x ${sign(-b)} ${abs(b)}} + C`;   // wrong inner sign
    const w3 = `${oneOver(a)}e^{${a}x} + C`;                        // missing constant
    const w4 = `-${oneOver(a)}e^{${a}x ${sign(b)} ${abs(b)}} + C`;
    const {choices:chE2, correctIndex:ciE2} = finalizeChoices([w1,w2,w3,w4], correct, 5);
    return {skill:"calculus", type:"mcq", prompt, choices:chE2, correctIndex:ciE2, hint:`\\int e^{ax}dx = e^{ax}/a + C`, explain:`Chain factor \\(${oneOver(a)||'1'}\\).`};
  }
  function genDefiniteIntegralPoly(){
    const a = rng(1,6) * (Math.random()<0.3?-1:1);
    const b = rng(-4,4);
    const p = rng(-3,0);
    const q = rng(1,4);
    const prompt = `Compute: \\( \\int_{${p}}^{${q}} (${a}x ${sign(b)} ${abs(b)})\\,dx \\)`;
    const ans = 0.5*a*(q*q - p*p) + b*(q-p);
    const {choices, correctIndex} = buildNumericMCQ(ans);
    return {skill:"calculus", type:"mcq", prompt, choices, correctIndex, hint:`Use FTOC on a linear function.`, explain:`Antiderivative: \\(${fracStr(a,2)}x^2 ${sign(b)} ${abs(b)}x\\).`};
  }
  // Linear Algebra generators
  function genLA_Mat2Vec2(){
    // [ [a,b],[c,d] ] * [x;y]
    const a=rng(-3,3)||1, b=rng(-3,3), c=rng(-3,3), d=rng(-3,3)||1;
    const x=rng(-3,3), y=rng(-3,3);
    const M = mat2(a,b,c,d); const v = vec(x,y); const r = mat2MulVec2(M,v);
    const prompt = `Compute \\[ ${matToLatex(M)} \\cdot ${vecToLatex(v)} \\]`;
    const correct = vecToLatex(r);
    // Distractors: swapped rows, transposed use, sign error
    const d1 = vecToLatex([r[1], r[0]]);
    const d2 = vecToLatex([ a*x + c*y, b*x + d*y ]); // using columns incorrectly
    const d3 = vecToLatex([ a*x - b*y, c*x - d*y ]);
    const d4 = vecToLatex([ b*x + a*y, d*x + c*y ]);
    const {choices, correctIndex} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    const hint = `Row-by-vector: first entry is $${a}\\cdot${x} + ${b}\\cdot${y}$.`;
    const explain = `$=${vecToLatex([a*x + b*y, c*x + d*y])}$.`;
    return {skill:"linalg", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genLA_Det2(){
    const a=rng(-4,4), b=rng(-4,4), c=rng(-4,4), d=rng(-4,4);
    const M = mat2(a,b,c,d); const val = det2(M);
    const prompt = `Compute \\[ \\det\\,${matToLatex(M)} \\]`;
    const correct = fmt(val);
    const {choices, correctIndex} = finalizeChoices([ fmt(a*d + b*c), fmt(a*b + c*d), fmt(a-d), fmt(b-c) ], correct, 5);
    const hint = `$\\det\\begin{bmatrix}a&b\\\\c&d\\end{bmatrix}=ad-bc$.`;
    const explain = `$= ${a}\\cdot${d} - ${b}\\cdot${c} = ${correct}$.`;
    return {skill:"linalg", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genLA_Mat2Mat2(){
    // A(2x2)*B(2x2)
    const A = mat2(rng(-3,3), rng(-3,3), rng(-3,3), rng(-3,3));
    const B = mat2(rng(-3,3), rng(-3,3), rng(-3,3), rng(-3,3));
    const R = mat2Mul(A,B);
    const prompt = `Compute \\[ ${matToLatex(A)} \\cdot ${matToLatex(B)} \\]`;
    const correct = matToLatex(R);
    // Distractors: BA, transpose result, and one with swapped middle terms
    const BA = mat2Mul(B,A);
    const d1 = matToLatex(BA);
    const d2 = matToLatex([[R[0][1],R[0][0]],[R[1][1],R[1][0]]]);
    const d3 = matToLatex([[A[0][0]*B[0][0] + A[1][0]*B[1][0], A[0][1]*B[0][1] + A[1][1]*B[1][1]], [A[1][0]*B[0][0] + A[0][0]*B[1][0], A[1][1]*B[0][1] + A[0][1]*B[1][1]]]);
    const d4 = matToLatex([[R[0][0],R[1][0]],[R[0][1],R[1][1]]]);
    const {choices, correctIndex} = finalizeChoices([d1,d2,d3,d4], correct, 5);
    const hint = `Row-by-column multiplication.`;
    const explain = `First entry: $(${A[0][0]})(${B[0][0]})+(${A[0][1]})(-${-B[1][0]})$ etc.`;
    return {skill:"linalg", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genLA_Trace(){
    const n = choice([2,3]);
    const M = Array.from({length:n}, _=> Array.from({length:n}, _=> rng(-3,3)));
    const tr = M.reduce((s,_,i)=> s + M[i][i], 0);
    const prompt = `Compute \\[ \\operatorname{tr}\\,${matToLatex(M)} \\]`;
    const correct = fmt(tr);
    const {choices, correctIndex} = finalizeChoices([ fmt(tr+1), fmt(tr-1), fmt(-tr), fmt(tr+2) ], correct, 5);
    const hint = `Sum of diagonal entries.`;
    const explain = `$=${M.map((r,i)=>M[i][i]).join(' + ')} = ${correct}$.`;
    return {skill:"linalg", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genLA_Dot(){
    const n = choice([2,3]);
    const v = Array.from({length:n}, _=> rng(-3,3));
    const w = Array.from({length:n}, _=> rng(-3,3));
    const dot = v.reduce((s,vi,i)=> s + vi*w[i], 0);
    const prompt = `Compute \\[ ${vecToLatex(v)} \\cdot ${vecToLatex(w)} \\]`;
    const correct = fmt(dot);
    const {choices, correctIndex} = finalizeChoices([ fmt(dot+1), fmt(dot-1), fmt(-dot), fmt(dot+2) ], correct, 5);
    const hint = `Multiply components and add.`;
    const explain = `$=${v.map((vi,i)=>`${vi}\\cdot${w[i]}`).join(' + ')} = ${correct}$.`;
    return {skill:"linalg", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function genLimit(){
    const x0 = rng(-5,5);
    const prompt = `Compute \\( \\lim_{h\\to 0} \\dfrac{( ${x0}+h )^2 - (${x0})^2}{h} \\).`;
    const ans = 2*x0;
    const hint = `Expand numerator then cancel h: \\((x_0+h)^2 - x_0^2 = 2x_0 h + h^2\\).`;
    const explain = `\\(= \\lim_{h\\to 0} (2x_0 + h) = 2 \\cdot ${x0}\\).`;
    const {choices, correctIndex} = buildNumericMCQ(ans);
    return {skill:"calculus", type:"mcq", prompt, choices, correctIndex, hint, explain};
  }
  function makeProblem(skill){
    if (skill==="arithmetic") return choice([genArithmetic, genArithmetic, genArithmetic])();
    if (skill==="algebra")   return choice([genLinear, genExpand, genFactor])();
    if (skill==="calculus")  return choice([
      genDerivativePoint,
      genLimit,
      genIntegralPoly,
      genIntegralTrig,
      genIntegralExp,
      genDefiniteIntegralPoly
    ])();
    if (skill==="probability") return choice([
      genCoinBinom,
      genTwoDiceSum,
      genIndependence,
      genExpectedDie,
      genChoose,
      genBayesLikelihoods,
      genBayesGivenB
    ])();
    if (skill==="linalg") return choice([
      genLA_Mat2Vec2,
      genLA_Det2,
      genLA_Mat2Mat2,
      genLA_Trace,
      genLA_Dot
    ])();
    return choice([
      genArithmetic,
      genLinear,
      genExpand,
      genFactor,
      genDerivativePoint,
      genLimit,
      genIntegralPoly,
      genIntegralTrig,
      genIntegralExp,
      genDefiniteIntegralPoly,
      genCoinBinom,
      genTwoDiceSum,
      genIndependence,
      genExpectedDie,
      genChoose,
      genLA_Mat2Vec2,
      genLA_Det2,
      genLA_Mat2Mat2,
      genLA_Trace,
      genLA_Dot
    ])();
  }

  const state = { running:false, queue:[], total:10, index:0, current:null, skill:"mixed" };
  function startSession(skill){
    state.running=true; state.skill=skill; state.index=0; state.queue=[]; state.total = (skill==="mixed") ? 10 : 8;
    for (let i=0;i<state.total;i++){ state.queue.push(makeProblem(skill==="mixed" ? "mixed" : skill)); }
    document.querySelectorAll("#skills .card button").forEach(b=>b.disabled=true);
    $("session").classList.add("open"); document.body.classList.add('modal-open');
    try{ window.scrollTo(0,0); }catch(_){ }
    nextProblem();
  }
  function endSession(){
    $("sessionBar").style.width = "100%";
    openFeedback(`Session complete — nice work!`, ()=>{
      document.querySelectorAll("#skills .card button").forEach(b=>b.disabled=false);
      $("session").classList.remove("open"); document.body.classList.remove('modal-open');
    }, 'Finish');
  }
  function nextProblem(){
    if (window.MathJax && MathJax.typesetClear) { try{ MathJax.typesetClear([$("problemCard")]); }catch(_){} }
    if (state.index>=state.total){ endSession(); return; }
    const p = state.queue[state.index]; state.current = p;
    $("skillTag").textContent = p.skill.charAt(0).toUpperCase()+p.skill.slice(1);
    $("progressTag").textContent = `${state.index+1} / ${state.total}`;
    $("prompt").innerHTML = p.prompt;
    $("hint").style.display="none"; $("hint").innerHTML = p.hint || "";
    $("feedbackModal").classList.remove('open');
    $("sessionBar").style.width = Math.round((state.index/state.total)*100) + "%";
    // snap overlay to top for each new problem on mobile
    try{ $("problemCard").scrollTo({top:0, behavior:'instant'}); }catch(_){ try{ $("problemCard").scrollTop = 0; }catch(__){} }
    // Always render as MCQ for mobile friendliness
    $("instruction").textContent = "Choose the correct answer.";
    const area = $("mcqArea"); area.innerHTML="";
    p.choices.forEach((c,i)=>{
      const btn=document.createElement("button"); btn.className="secondary";
      const isMatrix = /\\begin\{bmatrix\}|\\begin\{pmatrix\}/.test(c);
      btn.innerHTML = isMatrix ? `\\[${c}\\]` : `\\(${c}\\)`;
      btn.addEventListener("click", ()=> checkMCQ(i));
      area.appendChild(btn);
    });
    $("mcqArea").style.display="grid"; $("inputArea").style.display="none";
    // Typeset the entire card once at the end for reliability
    typeset($("problemCard"));
  }
  function openFeedback(html, onNext, nextLabel='Next'){
    const modal = $("feedbackModal");
    $("feedback").innerHTML = html;
    const nextBtn=$("nextFeedbackBtn"), closeBtn=$("closeFeedbackBtn");
    nextBtn.textContent = nextLabel;
    nextBtn.onclick = ()=>{ modal.classList.remove('open'); if (onNext) onNext(); };
    closeBtn.onclick = ()=>{ modal.classList.remove('open'); };
    modal.classList.add('open');
    typeset(modal);
  }
  function checkNumeric(){
    const p = state.current; if (!p) return; const val = parseNumber($("answerInput").value);
    const ok = nearlyEqual(val, p.answer);
    if (ok){ openFeedback(`✅ Correct! ${p.explain ? '<br>'+p.explain : ''}`, ()=>{ state.index++; nextProblem(); }); }
    else {
      state.queue.push(makeProblem(p.skill)); state.total++; $("progressTag").textContent = `${state.index+1} / ${state.total}`;
      openFeedback(`❌ Not quite. ${p.explain ? '<br>'+p.explain : ''}<br><span class=\"subtle\">Expected approximately ${fmt(p.answer)}.</span>`, null, 'Continue');
    }
  }
  function checkMCQ(idx){
    const p = state.current; if (!p) return; const correct = idx===p.correctIndex;
    if (correct){ openFeedback(`✅ Correct! ${p.explain ? '<br>'+p.explain : ''}`, ()=>{ state.index++; nextProblem(); }); }
    else {
      state.queue.push(makeProblem(p.skill)); state.total++; $("progressTag").textContent = `${state.index+1} / ${state.total}`;
      openFeedback(`❌ Not quite. ${p.explain ? '<br>'+p.explain : ''}`, null, 'Continue');
    }
  }

  document.querySelectorAll("#skills .card button").forEach(btn=>{ btn.addEventListener("click", ()=> startSession(btn.dataset.skill)); });
  // Keyboard shortcuts removed; use buttons only.
  $("hintBtn").addEventListener("click", toggleHint);
  $("skipBtn").addEventListener("click", ()=>{ state.index++; nextProblem(); });
  $("homeBtn").addEventListener("click", ()=>{
    state.running=false;
    document.querySelectorAll("#skills .card button").forEach(b=>b.disabled=false);
    $("session").classList.remove("open"); document.body.classList.remove('modal-open');
    try{ window.scrollTo(0,0); }catch(_){ }
  });
  // Optional: close when clicking backdrop (not the card)
  $("session").addEventListener('click', (e)=>{
    if (e.target === $("session")) { $("homeBtn").click(); }
  });
  function toggleHint(){ const h=$("hint"); h.style.display = h.style.display==="none" ? "block" : "none"; typeset(h); }

  // Theme follows system preference via CSS prefers-color-scheme.
  // Ensure any static LaTeX on initial view is rendered
  typeset(document.body);
  </script>
</body>
</html>
